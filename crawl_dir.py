"""
DOCUMENTATION GENERATED BY AI

This script generates comprehensive docstrings for a given project's source code files
using OpenAI's Chat Completion. The generated docstrings are then added to the respective
source code files and also saved in a JSON file as a backup.

Main functionality:
1. Extract relevant source code files from the project directory.
2. Generate docstrings for the extracted files using OpenAI's Chat Completion.
3. Save generated docstrings in a JSON file.
4. Add generated docstrings to the respective source code files.

Dependencies:
- openai: Install via `pip install openai` to interact with OpenAI's API.
- python-dotenv: Install via `pip install python-dotenv` to load environment variables.

Key implementation details:
1. `generate_docstring(code, ncalls=0)`: Generates a docstring for the given code using OpenAI's Chat Completion.
2. `extract_files(path)`: Extracts all relevant source code files from a path directory.
3. `encode_files(files)`: Generates docstrings for the given list of files and returns a list of encoded messages.
4. `save_as_json(data, output_file)`: Saves the provided data in a JSON file.
5. `add_docstrings_to_files(docs_list)`: Adds generated docstrings to the respective source code files.
6. In the main block, the script processes the project directory, generates docstrings, saves the results in a JSON file, and adds the docstrings to the source files.

Additional notes:
- This script supports Python (.py), JavaScript (.js), HTML (.html), and CSS (.css) files.
- Set the `project_directory` variable to the root directory of your project.
- Ensure that the OpenAI API key is set as an environment variable.
- The generated JSON backup file will be named 'docs.json'.
- The script also includes details such as author's name and copyright year in the generated docstring.

Please keep your API key secure, ensure proper versioning of the dependencies, and maintain a backup
of the original source files before using this script.



Copyright 2023, Joe Crowley, All rights reserved.
"""
import openai
import os
import time
import json
from dotenv import load_dotenv

load_dotenv()
openai.api_key = os.environ.get("OPENAI_API_KEY")

def generate_docstring(code, ncalls = 0):
    """
    Generates a docstring for the given file using OpenAI's Chat Completion.

    Args:
        code (str): Contents the file ('js', 'py', 'css', or 'html').

    Returns:
        str: The generated docstring.
    """

    # Create a prompt for the model
    system_prompt = f"Write a comprehensive docstring for the code provided, which will serve as a guide for developers. Include the following information in the docstring:\n1. The main purpose and functionality of the code\n2. Related files and dependencies\n3. Location of key implementation details\n4. Any additional information essential for understanding and maintaining the code.\n\nWrite the documentation with indentation and formatting for readablity. Do not include anything other than the docstring."
    user_prompt = f"Here is the code:\n```\n{code}\n```\n"

    # Set model parameters
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
                ],
            temperature=0.8,
            max_tokens=800,
        )

        # Extract the generated docstring
        docstring = response.choices[0].message["content"].strip()
    except Exception as err:
        fail_str = f'FAILED TO GENERATE DOCSTRING\n\n{err.args[0]}'
        print(fail_str)
        if ncalls < 10:
            print(f'sleeping for {ncalls*5} seconds and trying again\n')
            time.sleep(ncalls*5)
            return generate_docstring(code, ncalls + 1)
        else:
            print("Failed 10 times... returning empty str")
            return ''

    return docstring

def extract_files(path):
    relevant_files = []
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith(('.js', '.py', '.html', '.css')):
                relevant_files.append(os.path.join(root, file))
    return relevant_files

def encode_files(files):
    encoded_messages = []

    for file in files:
        with open(file, 'r', encoding='utf-8') as f:
            content = f.read()
        if not content: continue

        docs = generate_docstring(content)
        if not docs: continue

        message = {
        "role": "user",
        "content": f'FILE: {file}\n\nCODE:\n```\n{content}\n```',
        "file": file,
        "author": "Joe Crowley",
        "year": "2023",
        "docs": docs
        }

        encoded_messages.append(message)

        print(f'docs for {file}:\n{docs}\n\n')

    return encoded_messages

def save_as_json(data, output_file):
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

def add_docstrings_to_files(docs_list):
    def get_comment_syntax(file_type):
        if file_type == 'py':
            return '"""', '"""'
        elif file_type == 'C' or file_type == 'cpp' or file_type == 'cxx' or file_type == 'cc':
            return '/*', '*/'
        elif file_type == 'js' or file_type == 'css':
            return '/*', '*/'
        elif file_type == 'html':
            return '<!--', '-->'
        else:
            raise ValueError(f"Unsupported file type: {file_type}")

    for doc in docs_list:
        file_path = doc["file"]
        file_type = file_path.split('.')[-1]

        start_comment, end_comment = get_comment_syntax(file_type)

        docs = doc["docs"].replace(start_comment,'').replace(end_comment,'')
        year = doc["year"]
        author = doc["author"]

        with open(file_path, 'r') as file:
            file_content = file.read()

        modified_content = f"{start_comment}\nDOCUMENTATION GENERATED BY AI\n{docs}\n\nCopyright {year}, {author}, All rights reserved.\n{end_comment}\n{file_content}"

        with open(f'{file_path}', 'w') as file:
            file.write(modified_content)

if __name__ == '__main__':
    project_directory = '.' # Set to the root directory of your Django project
    relevant_files = extract_files(project_directory)
    encoded_messages = encode_files(relevant_files)
    output_file = 'docs.json'
    save_as_json(encoded_messages, output_file)
    with open(output_file,'r') as f:
        docs_list = json.load(f)
    add_docstrings_to_files(docs_list)
